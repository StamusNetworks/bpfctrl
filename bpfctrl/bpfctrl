#!/usr/bin/env python3

"""A bpftool wrapper to handle eBPF maps."""

import argparse
import ipaddress
import json
import shutil
import socket
import subprocess
import sys


def convert_to_ip(ip_str):
    """
        Convert a string into an IP address.

        :param ip_str: the ip to convert, can be like X.X.X.X or X:X:X:X:X:X, or
                       an int (decimal notation) converted into a string

        :return: an ip address
    """
    try:
        ip_addr = ipaddress.ip_address(int(ip_str))
    except ValueError:
        ip_addr = ipaddress.ip_address(ip_str)
    ip_int = int(ipaddress.ip_address(ip_addr))
    return ipaddress.ip_address(socket.htonl(ip_int))


def convert_to_value(val):
    """
        Transform a value (an string of uint 32) into an array of 4 str(int)
        corresponding of the value of each byte.
    """
    value = ipaddress.ip_address(int(val))
    value = str(value).split(".")
    return value


def convert_to_ip_value(ipval):
    """
        Convert a string into an IP address and the value associated.

        :param ipval: a string like 'ip=value'

        :return: an array like [ip, value]
    """
    res = ipval.split('=')
    if len(res) == 1:
        res.append('')
    res[0] = convert_to_ip(res[0])
    res[1] = convert_to_value(res[1])
    return res


def convert_to_0_value(val):
    """
        Given a value (u32), return an array like [0, value]

        :param value: a u32 converted into a string

        :return: ['0.0.0.0', value]
    """
    res = convert_to_ip_value("0=" + val)
    res[0] = str(res[0])
    return res


def ip_subparser_creation(subparsers):
    """Add a parser dedicated at the eBPF map of ips in the subparsers."""
    des = {
        # parser
        'ip': 'Keys of the eBPF map are IPv4 addresses.',
        # action group help
        'actions-ip': 'At least one action is needed. Adding are done before\
                      removing. Dump and get are executed after.',
        # actions
        'add': 'Add all the ip adresses given in the eBPF map at the \
                associated values.',
        'remove': 'Remove all the ip adresses given in the eBPF map',
        'dump': 'Dump the eBPF map on stdout or in a file if <path> is \
                 precised.',
        'get': 'Check if the IP is present on the map. If it is, displays\
                its value.',
        # options
        'cpu': 'If dump or get options are activated, display the value for\
            each cpu. If the eBPF map have not these precision, do\
            nothing.',
        'json': 'Output and file created will be in JSON format.'
    }
    parser_ip = subparsers.add_parser('ip', help=des['ip'])
    actions_ip = parser_ip.add_argument_group(
        title='ACTIONS', description=des['actions-ip'])
    actions_ip.add_argument('-a', '--add', metavar=('IP=value'), nargs='+',
                            type=convert_to_ip_value, default=[], help=des['add'])
    actions_ip.add_argument('-r', '--remove', metavar=('IP'), nargs='+',
                            type=convert_to_ip, default=[],
                            help=des['remove'])
    actions_ip.add_argument('-d', '--dump', nargs='?', metavar=('<path>'),
                            default=False, help=des['dump'])
    actions_ip.add_argument('-g', '--get', nargs=1, metavar=('IP'),
                            type=convert_to_ip, default=False, help=des['get'])
    parser_ip.add_argument('--cpu', action='store_true',
                           default=False, help=des['cpu'])
    parser_ip.add_argument('--json', action='store_true',
                           default=False, help=des['json'])


def uniq_subparser_creation(subparsers):
    """Add a parser dedicated at the eBPF map of one int in the subparsers."""
    des = {
        # parser
        'uniq': 'A map that contains one integer with a key 0.',
        # action group help
        'actions-uniq': 'At least one action is needed. Set is done before\
                        dump.',
        # actions
        'set': 'Set the map with the value given.',
        'dump': 'Dump the eBPF map on stdout or in a file if <path> is \
                 precised.',
        # options
        'json': 'Output and file created will be in JSON format.'
    }
    parser_uniq = subparsers.add_parser(
        'uniq', help=des['uniq'])
    actions_uniq = parser_uniq.add_argument_group(
        title='ACTIONS', description=des['actions-uniq'])
    actions_uniq.add_argument('-s', '--set', metavar=('value'),
                              nargs=1, default=[], type=convert_to_0_value,
                              help=des['uniq'])
    actions_uniq.add_argument('-d', '--dump', nargs='?', metavar=('<path>'),
                              default=False, help=des['dump'])
    parser_uniq.add_argument('--json', action='store_true',
                             default=False, help=des['json'])


def parser_creation():
    """
        Create a parser for the command line of the programm.

        :return: a parser
    """
    # messages display in the help
    des = {'help': 'Show this help message and exit.',
           'map': 'Path to the eBPF map.'
           }

    parser = argparse.ArgumentParser(
        usage='%(prog)s [--help] MAP TYPE ACTIONS',
        formatter_class=argparse.RawDescriptionHelpFormatter,
        epilog="""
ACTIONS:
ip commands: --add, --get, --remove, --dump
uniq commands: --set, --dump

A detailed help for actions is available with:
bpfctrl -m MAP TYPE --help""")

    map_path = parser.add_argument_group(title='MAP')
    map_path.add_argument('-m', '--map', required=True,
                          nargs=1, help=des['map'])
    subparsers = parser.add_subparsers(dest='map_type', title='TYPE',
                                       prog='bpfctrl MAP',
                                       help='Type of the eBPF map.')
    ip_subparser_creation(subparsers)
    uniq_subparser_creation(subparsers)

    return parser


def arg_parse():
    """
        Parse the command line

        :return: arguments as Namespace [option:[args]/Boolean]
    """
    parser = parser_creation()
    args = parser.parse_args()

    if args.map_type is None:
        exit(parser.format_help())
    if (args.map_type == 'ip' and args.add == [] and args.remove == []
            and args.dump == False and args.get == False):
        exit(parser.format_help())
    elif (args.map_type == 'uniq' and args.dump == False
          and args.set == []):
        exit(parser.format_help())
    return args


def exit_bpf_error(stdout):
    """
        Exit with the error returned by bpf.

        :param stdout: output of the bpftool command like :
                       '{"error":"bpf obj get (/sys/fs/bpf): Permission
                        denied"}\n'
    """
    stdout = stdout.replace('"', "").replace("\n", "")
    stdout_split = stdout[1:].split(":")
    exit_message = stdout_split[2].replace("}", "")
    sys.exit(exit_message.lstrip())


def command_action(map_path, action, key):
    """Create a list of commands to do action on the eBPF map with the key"""
    key = str(key).split(".")
    command = ["bpftool", "map", action, "pinned", map_path, "key"]
    command.extend(key)
    return command


def map_modification(map_path, action, ips, values=None):
    """
        Add or remove IP adresses of the eBPF map given.

        :param map_path: path to the eBPF map
        :param action: "update" or "delete"
        :param ips: a list of ip
        :param values: a list of the values associated with the ip of ips

        :return: None
    """
    len_ip = len(ips)
    for i in range(len_ip):
        command = command_action(map_path, action, ips[i])
        if action == "update":
            command.append("value")
            command.extend(values[i])
        call = subprocess.run(command, encoding='utf-8',
                              stdout=subprocess.PIPE, stderr=subprocess.PIPE)
        if call.returncode != 0:
            exit_bpf_error(call.stderr)


def ip_ntohl(ip):
    """Return the ip address after application of the ntohl on it"""
    ip_int = int(ipaddress.ip_address(ip))
    ip_int = socket.ntohl(ip_int)
    return ipaddress.ip_address(ip_int)


def hex_array_to_ip(hex_array):
    """
        Transform an array of hexadecimal values "0xaa" into an IP address.

        :param array: an array of hexademial numbers "Oxaa"

        :return: an IP
    """
    ip_hex = ''.join(['{0[2]}{0[3]}'.format(el) for el in hex_array])
    return ip_ntohl(bytes.fromhex(ip_hex))


def hex_array_to_int(hex_array):
    """
        Transform an array of hexadecimal values "0xaa" into an int.

        :param array: an array of hexademial numbers "Oxaa"

        :return: an int
    """
    int_hex = ''.join(['{0[2]}{0[3]}'.format(el) for el in hex_array])
    return int(int_hex, 16)


def cpu_parse(json_result, dict_bool):
    """
        Parse a list of dictionnaries [{'cpu', 'value'} into a dictionnary or
        the sum of all the 'value'.

        :param json_result: a list of dictionnaries {'cpu', 'value'} where
                            'cpu' value is an int and 'value' value is an array
                            of hexadecimal number ["0xaa", ...]
        :param dict_bool: if True the result is a dictionnary, else an int.

        :return: a dictionnary {cpu:value, ...} or the sum of all the values.
    """
    vals = []
    for j in json_result:
        vals.append((j['cpu'], hex_array_to_int(j['value'])))
    vals = dict(vals)
    if dict_bool:
        return vals
    return sum(vals.values())


def parse_json_output(json_output, map_type, cpu_flag):
    """
        Parse a json output of a bpftool command, transform it in a dictionnary
        {ip:{cpu:int}} or {ip:int}. The value is computed by transforming the
        hexademimal values of the json output into an int.

        :param json_output: a dictionnary (obtained with a json.load command)
        :param map_type: 'ip' or 'uniq', type of data stored in the map
        :param cpu_flag: a boolean that indicates the type of dictionnary to
                         return

        :return: a dictionnary
    """
    key_transformation = {
        'ip': (lambda key: str(hex_array_to_ip(key))),
        'uniq': hex_array_to_int}

    output = []
    if not isinstance(json_output, list):
        json_output = [json_output]
    for j in json_output:
        key = key_transformation[map_type](j['key'])
        try:
            dump_value = j['values']
        except KeyError:
            dump_value = j['value']
            value = hex_array_to_int(dump_value)
        else:
            value = cpu_parse(dump_value, cpu_flag)
        output.append((key, value))
    return dict(output)


def output_string(dic, json_flag):
    """
        Given a dict dic={key:value} or {key:{cpu : val}}, create the output of
        the programm and return it as a string. It can be in JSON format if
        json_flag is True.
        If it is not in JSON format, the output is :
        KEY   VALUE or KEY VAL0 VAL1 VAL2 ...
    """
    if json_flag:
        return json.dumps(dic, indent=4)

    res = ""
    if not dic:
        return res
    keys = list(dic.keys())
    if isinstance(dic[keys[0]], int):
        for k in keys:
            res += "{}    {}\n".format(k, dic[k])
    else:
        for k in keys:
            values = list(dic[k].values())
            res += k + "    "
            res += "    ".join(['{}'.format(val) for val in values]) + "\n"
    return res[0:len(res) - 1]


def map_dump(ebpf_map, path, map_type, json_flag, cpu_flag):
    """
        Print the dump of the eBPF map given or store it into a JSON file.

        :param ebpf_map: path to the eBPF map
        :param path: path to the file in which the dump will be stored,
                     None if the dump is displayed on stdout.
        :param map_type: 'ip' or 'uniq', type of data stored in the map
        :param json_flag: A boolean that indicates if the output is in JSON
                          format.
        :param cpu_flag: A boolean that indicates if the value per cpu are
                         displayed (True) or if it is their sum. Do nothing if
                         the eBPF map have not the value per each cpu.

        :return: None
    """
    call = subprocess.run(["bpftool", "map", "dump", "pinned", ebpf_map, "-j"],
                          encoding='utf-8', stdout=subprocess.PIPE)

    if call.returncode != 0:
        exit_bpf_error(call.stdout)

    dump = json.loads(call.stdout)
    dic = parse_json_output(dump, map_type, cpu_flag)
    if map_type == 'uniq':
        output = dic[0]
    else:
        output = output_string(dic, json_flag)
    if path is None:
        print(output)
    else:
        with open(path, 'w') as file:
            file.write(output)
            file.close()


def map_get(ebpf_map, key, map_type, json_flag, cpu_flag):
    """
        Chek if an IP address is in the eBPF map given, if it is, display its
        value, else exit with an error.

        :param ebpf_map: path to the eBPF map
        :param key: the ip to check(ipaddress)
        :param map_type: 'ip' or 'uniq', type of data stored in the map
        :param cpu_flag: A boolean that indicated if the value per cpu are
                         displayed(True) or if it is their sum. Do nothing if
                         the eBPF map have not a value per each cpu.
        :param json_flag: A boolean that indicates if the output is in JSON
                          format.

        :return: None
    """
    command = command_action(ebpf_map, "lookup", key)
    command.append("-p")
    call = subprocess.run(command, encoding='utf-8', stdout=subprocess.PIPE)
    if call.returncode != 0:
        exit_bpf_error(call.stdout)

    res = call.stdout
    ip_str = str(ip_ntohl(key))
    if res == "null\n":
        sys.exit("The key {} is not in the map {}.".format(ip_str, map))

    output = parse_json_output(json.loads(res), map_type, cpu_flag)
    print(output_string(output, json_flag))


def main():
    args = arg_parse()

    if shutil.which("bpftool") is None:
        sys.exit("Bpftool not found.")

    ebpf_map = args.map[0]
    if args.map_type == 'ip':
        add_ips = list(map(lambda pos: pos[0], args.add))
        add_value = list(map(lambda pos: pos[1], args.add))
        map_modification(ebpf_map, "update", add_ips, add_value)
        map_modification(ebpf_map, "delete", args.remove)
        if args.get != False:
            map_get(ebpf_map, args.get[0], args.map_type, args.json, args.cpu)
        if args.dump != False:
            map_dump(ebpf_map, args.dump, args.map_type, args.json, args.cpu)
    else:
        set_ip = list(map(lambda pos: pos[0], args.set))
        set_value = list(map(lambda pos: pos[1], args.set))
        map_modification(ebpf_map, "update", set_ip, set_value)
        if args.dump != False:
            map_dump(ebpf_map, args.dump, args.map_type, args.json, False)


if __name__ == '__main__':
    main()
